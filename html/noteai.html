<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NoteAI - Intelligent Note Taking</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        *:focus {
            outline: none !important;
        }

        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #f4e4bc 0%, #e8d5a3 100%);
            font-family: 'Georgia', serif;
            overflow: hidden;
            height: 100vh;
            cursor: crosshair;
        }

        .thoughts-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .thought {
            position: fixed;
            /* background: rgba(139, 115, 85, 0.00); */
            border: none;
            font-family: 'Georgia', serif;
            font-size: 1.2rem;
            color: #2c1810;
            padding: 6px 10px;
            border-radius: 6px;
            transition: background 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            white-space: pre-wrap;
            z-index: 2;
            user-select: none;
            outline: none !important; /* Remove all outlines */
        }

    

        .thought.dragging {
            cursor: grabbing !important;
            transform: scale(1.05) !important;
            z-index: 10 !important;
            background: rgba(139, 115, 85, 0.15) !important;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                0 4px 12px rgba(0, 0, 0, 0.15) !important;
            transition: none !important;
        }

        .thought:hover:not(.dragging) {
            background: rgba(139, 115, 85, 0.12);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }

        .thought.editing {
            cursor: text;
            user-select: text;
            outline: none; /* Remove browser's default contentEditable outline */
        }

        /* thought.editing and current-thought should be the same thing, the current thought is the one that is being edited */

        .thought.current-thought {
            background: rgba(139, 115, 85, 0.15);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5);
            outline: none !important; /* Remove outline from current thought */
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            25% { transform: translateY(-3px) rotate(1deg); }
            50% { transform: translateY(-6px) rotate(0deg); }
            75% { transform: translateY(-3px) rotate(-1deg); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .mouse-blob {
            position: fixed;
            width: 12px;
            height: 12px;
            background: rgba(44, 24, 16, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 3;
            animation: float 2s ease-in-out infinite;
        }

        /* Ink blot styles */
        .ink-blot {
            position: fixed;
            border-radius: 60% 40% 50% 45%;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 5;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transform-origin: center center;
        }

        .ink-blot:active {
            transform: scale(0.95);
        }

        .ink-blot:not(.menu-expanded)::before {
            display: none;
        }

        .ink-blot:not(.menu-expanded)::after {
            display: none;
        }

        .ink-blot.menu-expanded::before {
            content: '';
            position: absolute;
            top: 15px;
            left: 20px;
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: pulse 3s ease-in-out infinite;
        }

        .ink-blot.menu-expanded::after {
            content: '';
            position: absolute;
            bottom: 10px;
            right: 15px;
            width: 12px;
            height: 6px;
            background: #0f0907;
            border-radius: 50%;
            opacity: 0.6;
        }

        /* Menu state - styling only, no size changes */
        .ink-blot.menu-expanded {
            /* All sizing handled by JavaScript */
            transition: all 0.3s ease;
        }

        .menu-item {
            border-radius: 50%;
        }

        .menu-item:hover {
            background: rgba(255, 255, 255, 0.9) !important;
            color: #1a0f0a !important;
        }

        @keyframes fadeIn {
            from { 
                opacity: 0; 
                transform: scale(0.5); 
            }
            to { 
                opacity: 1; 
                transform: scale(1); 
            }
        }

        .ink-blot:hover .menu-item {
            opacity: 1;
            transform: scale(1);
        }


        /* Clear Button */
        .clear-button {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(44, 24, 16, 0.1);
            border: 2px solid rgba(44, 24, 16, 0.2);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: rgba(44, 24, 16, 0.3);
            transition: all 0.3s ease;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .clear-button:hover {
            background: #dc3545;
            border-color: #c82333;
            color: white;
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
        }

        .clear-button:active {
            transform: scale(0.95);
        }

        .ink-trail {
            position: fixed;
            width: 4px;
            height: 4px;
            background: rgba(44, 24, 16, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 4;
            animation: fadeOut 2s ease-out forwards;
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0); }
        }
    </style>
</head>
<body>
    <div class="thoughts-container" id="thoughtsContainer">
        <!-- Thoughts will be typed here -->
    </div>
    
    <div class="clear-button" id="clearButton">Ã—</div>
    <div class="ink-blot" id="inkBlot"></div>

    <script>
        // Configuration
        const CONFIG = {
            blot: {
                moveSpeed: 0.08,
                approachDistance: 120,
                patientDistance: 110,
                menuRadius: 50,
                smoothingFactor: 0.92
            },
            typing: {
                mouseStillThreshold: 30,
                storageKey: 'noteai-thoughts'
            }
        };

        // Global variables
        let mouseX = 0;
        let mouseY = 0;
        let appMode = 'new_thought'; // 'new_thought' or 'current_thought'
        let mouseBlob = null;
        let currentThought = null; // This could replace appMode, if currentThought == null then appMode = new_thought else appMode = currentThought
        let thoughts = [];
        let blot = null; // Should this ever be null?

        // === THOUGHT CLASS ===
        class Thought {
            constructor(text, x, y) {
                this.text = text;
                this.x = x;
                this.y = y;
                this.element = this.createElement();
                this.isActive = false;
                this.isDragging = false;
                this.dragStartX = 0;
                this.dragStartY = 0;
                this.dragThreshold = 5;
            }

            createElement() {
                const element = document.createElement('div');
                element.className = 'thought';
                element.style.left = this.x + 'px';
                element.style.top = this.y + 'px';
                element.textContent = this.text;
                element.contentEditable = false; // What is this for? The div is not editable by defaut? ok
                return element;
            }


            startDrag() {
                this.isDragging = true;
                this.element.classList.add('dragging');
                this.select();
            }

            drag(e) {
                if (this.isDragging) {
                    const newX = this.x + (e.clientX - this.dragStartX);
                    const newY = this.y + (e.clientY - this.dragStartY);
                    this.moveTo(newX, newY);
                    this.dragStartX = e.clientX;
                    this.dragStartY = e.clientY;
                }
            }

            endDrag() {
                this.isDragging = false;
                this.element.classList.remove('dragging');
                if (thoughtManager) {
                    thoughtManager.saveThoughts();
                }

                // Update blot position if this is the current thought
                if (this === currentThought && blot) {
                    blot.onCurrentThoughtChanged();
                }
            }

            select() {
                // Set as current thought
                if (currentThought && currentThought !== this) {
                    currentThought.setActive(false);
                }
                currentThought = this;
                this.setActive(true);
                appMode = 'current_thought';
            }

            enableEditing() {
                this.element.contentEditable = true;
                this.element.focus();
                
                // Position cursor at end of text
                const range = document.createRange();
                const selection = window.getSelection();
                range.selectNodeContents(this.element);
                range.collapse(false);
                selection.removeAllRanges();
                selection.addRange(range);
            }

            disableEditing() {
                this.element.contentEditable = false;
                this.text = this.element.textContent;
            }

            setActive(active) {
                this.isActive = active;
                if (active) {
                    this.element.classList.add('current-thought');
                    this.enableEditing();
                } else {
                    this.element.classList.remove('current-thought');
                    this.disableEditing();
                }
            }

            updateText(text) {
                this.text = text;
                this.element.textContent = text;
            }

            moveTo(x, y) {
                this.x = x;
                this.y = y;
                this.element.style.left = x + 'px';
                this.element.style.top = y + 'px';
            }

            format(type) {
                switch (type) {
                    case 'bold':
                        this.element.style.fontWeight = 
                            this.element.style.fontWeight === 'bold' ? 'normal' : 'bold';
                        break;
                    case 'italic':
                        this.element.style.fontStyle = 
                            this.element.style.fontStyle === 'italic' ? 'normal' : 'italic';
                        break;
                    case 'upper':
                        this.text = this.text.toUpperCase();
                        this.element.textContent = this.text;
                        break;
                    case 'lower':
                        this.text = this.text.toLowerCase();
                        this.element.textContent = this.text;
                        break;
                }
            }

            remove() {
                this.element.remove();
            }
        }

        // === BLOT CLASS ===
        /**
         * MODULE: Simplified Ink Blot Companion
         * PURPOSE: Simple companion that follows the current thought
         * 
         * INPUTS:
         * - currentThought variable - determines positioning
         * 
         * OUTPUTS:
         * - Visual blot element positioned next to current thought
         * 
         * BEHAVIOR:
         * - Moves to be next to current thought when it changes
         * - Simple positioning without complex menu system
         */
        class Blot {
            constructor() {
                this.element = document.getElementById('inkBlot');
                // Default blot size - can be changed dynamically
                this.blotWidth = 75;
                this.blotHeight = 70;
                this.menuWidth = 115;
                this.menuHeight = 110;
                
                this.x = window.innerWidth / 2;
                this.y = window.innerHeight / 2;
                this.menuExpanded = false;
                this.targetThought = null; // Track which thought this blot is positioned next to
                this.menuItems = [
                    { text: 'B', action: 'bold', angle: 0 },
                    { text: 'I', action: 'italic', angle: 60 },
                    { text: 'a', action: 'lower', angle: 120 },
                    { text: 'A', action: 'upper', angle: 180 },
                    { text: 'Ã—', action: 'delete', angle: 300 }
                ];
                this.updateSize();
                this.updatePosition();
                this.renderBlot();
            }

            // Set blot size and maintain center position
            setSize(width, height) {
                this.blotWidth = width;
                this.blotHeight = height;
                this.updateSize();
                this.updatePosition(); // Recalculate position to maintain center
            }

            // Update the actual DOM element size and styling
            updateSize() {
                const currentWidth = this.menuExpanded ? this.menuWidth : this.blotWidth;
                const currentHeight = this.menuExpanded ? this.menuHeight : this.blotHeight;
                
                this.element.style.width = currentWidth + 'px';
                this.element.style.height = currentHeight + 'px';
                this.element.style.background = 'radial-gradient(circle at 30% 30%, #2c1810, #1a0f0a)';
            }

            // Get current center offsets based on current size
            getCurrentCenterOffsets() {
                const currentWidth = this.menuExpanded ? this.menuWidth : this.blotWidth;
                const currentHeight = this.menuExpanded ? this.menuHeight : this.blotHeight;
                return {
                    centerX: currentWidth / 2,
                    centerY: currentHeight / 2
                };
            }

            updatePosition() {
                if (currentThought) {
                    // Position to the left of current thought (center coordinates)
                    this.x = currentThought.x - 60;
                    this.y = currentThought.y + 20;
                    this.targetThought = currentThought; // Remember which thought we're positioned next to
                    
                    // Keep within screen bounds (accounting for current blot size)
                    const { centerX, centerY } = this.getCurrentCenterOffsets();
                    this.x = Math.max(centerX, Math.min(window.innerWidth - centerX, this.x));
                    this.y = Math.max(centerY, Math.min(window.innerHeight - centerY, this.y));
                } else if (this.targetThought) {
                    // Stay positioned next to the last target thought, don't move to center
                    this.x = this.targetThought.x - 60;
                    this.y = this.targetThought.y + 20;
                    
                    // Keep within screen bounds (accounting for current blot size)
                    const { centerX, centerY } = this.getCurrentCenterOffsets();
                    this.x = Math.max(centerX, Math.min(window.innerWidth - centerX, this.x));
                    this.y = Math.max(centerY, Math.min(window.innerHeight - centerY, this.y));
                } else {
                    // Only go to center if there's no target thought at all
                    this.x = window.innerWidth / 2;
                    this.y = window.innerHeight / 2;
                }
                
                // Position using center coordinates (subtract half current width/height)
                const { centerX, centerY } = this.getCurrentCenterOffsets();
                this.element.style.left = (this.x - centerX) + 'px';
                this.element.style.top = (this.y - centerY) + 'px';
            }

            // Called from ThoughtManager when currentThought changes
            onCurrentThoughtChanged() {
                this.updatePosition();
            }

            // Called from ThoughtManager on hover
            expandMenu() {
                if (currentThought || thoughts.length > 0) {
                    this.menuExpanded = true;
                    this.element.classList.add('menu-expanded');
                    this.updateSize(); // Update size first
                    this.updatePosition(); // Then reposition to maintain center
                    this.renderBlot();
                }
            }

            // Called from ThoughtManager on mouse leave
            collapseMenu() {
                this.menuExpanded = false;
                this.element.classList.remove('menu-expanded');
                this.updateSize(); // Update size first
                this.updatePosition(); // Then reposition to maintain center
                this.renderBlot();
            }

            renderBlot() {
                if (this.menuExpanded) {
                    this.element.innerHTML = this.getMenuHTML();
                } else {
                    this.element.innerHTML = '';
                }
            }

            getMenuHTML() {
                let html = '';
                // Use current blot center as reference
                const { centerX, centerY } = this.getCurrentCenterOffsets();
                const radius = 30;
                
                this.menuItems.forEach((item, index) => {
                    const angle = item.angle;
                    const x = centerX + radius * Math.cos(angle * Math.PI / 180);
                    const y = centerY + radius * Math.sin(angle * Math.PI / 180);
                    
                    html += `<div class="menu-item" data-action="${item.action}" style="
                        position: absolute;
                        left: ${x - 12}px;
                        top: ${y - 12}px;
                        width: 24px;
                        height: 24px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 0.9rem;
                        font-weight: bold;
                        color: white;
                        cursor: pointer;
                        transition: all 0.2s ease;
                        animation: fadeIn 0.3s ease ${index * 0.05}s both;
                    ">${item.text}</div>`;
                });
                return html;
            }

            // Called from ThoughtManager when menu item is clicked
            executeAction(action) {
                // Use targetThought (the thought we're positioned next to) instead of currentThought
                const targetThought = this.targetThought;
                if (!targetThought) return;
                
                switch (action) {
                    case 'bold':
                    case 'italic':
                    case 'upper':
                    case 'lower':
                        targetThought.format(action);
                        if (thoughtManager) thoughtManager.saveThoughts();
                        break;
                    case 'move':
                        // TODO: Implement move functionality
                        break;
                    case 'delete':
                        // Delete the target thought
                        const index = thoughts.indexOf(targetThought);
                        if (index > -1) {
                            targetThought.element.remove();
                            thoughts.splice(index, 1);
                            this.targetThought = null;
                            if (currentThought === targetThought) {
                                currentThought = null;
                                appMode = 'new_thought';
                            }
                            if (thoughtManager) {
                                thoughtManager.updateMouseBlob();
                                thoughtManager.saveThoughts();
                            }
                        }
                        break;
                }
                this.collapseMenu();
            }
        }

        // === THOUGHT MANAGER ===
        /**
         * MODULE: Thought Manager
         * PURPOSE: Manages thought creation, editing, and keyboard input handling
         * 
         * INPUTS:
         * - Keyboard events (keydown, keypress)
         * - Mouse position and movement
         * - User typing input
         * 
         * OUTPUTS:
         * - New thought creation at mouse position
         * - Character addition to existing thoughts
         * - Backspace/delete functionality
         * - App mode switching between 'new_thought' and 'current_thought'
         * 
         * BEHAVIOR:
         * - Listens for all keyboard input to detect typing
         * - Creates thoughts at mouse cursor location
         * - Handles Enter key for line breaks
         * - Handles Backspace for character/thought deletion
         * - Manages mouse blob visibility based on app mode
         */
        class ThoughtManager {
            constructor() {
                this.loadThoughts();
                this.setupEventListeners();
            }

            setupEventListeners() {
                // Mouse tracking variables for drag detection
                let mouseDownTime = 0;
                let mouseDownX = 0;
                let mouseDownY = 0;
                let hasMoved = false;
                let draggedThought = null;

                // Mouse movement tracking
                document.addEventListener('mousemove', (e) => {
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                    this.updateAppMode();

                    // Handle dragging
                    if (mouseDownTime > 0 && draggedThought) {
                        const deltaX = Math.abs(e.clientX - mouseDownX);
                        const deltaY = Math.abs(e.clientY - mouseDownY);
                        
                        if (deltaX > draggedThought.dragThreshold || deltaY > draggedThought.dragThreshold) {
                            hasMoved = true;
                            if (!draggedThought.isDragging) {
                                draggedThought.startDrag();
                            }
                            draggedThought.drag(e);
                        }
                    }
                });

                // Single mouse down handler for all thoughts
                document.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('thought')) {
                        e.preventDefault();
                        draggedThought = thoughts.find(t => t.element === e.target);
                        if (draggedThought) {
                            mouseDownTime = Date.now();
                            mouseDownX = e.clientX;
                            mouseDownY = e.clientY;
                            hasMoved = false;
                            draggedThought.dragStartX = e.clientX;
                            draggedThought.dragStartY = e.clientY;
                        }
                    }
                });

                // Single mouse up handler - ALWAYS clears drag state
                document.addEventListener('mouseup', (e) => {
                    if (mouseDownTime > 0 && draggedThought) {
                        if (draggedThought.isDragging) {
                            draggedThought.endDrag();
                        } else if (!hasMoved) {
                            // Simple click - select the thought
                            this.setCurrentThought(draggedThought);
                        }
                        // Always reset drag tracking variables
                        mouseDownTime = 0;
                        mouseDownX = 0;
                        mouseDownY = 0;
                        hasMoved = false;
                        draggedThought = null;
                    }
                });

                // Blot hover handling
                document.addEventListener('mouseenter', (e) => {
                    if (e.target.id === 'inkBlot' && blot) {
                        blot.expandMenu();
                    }
                }, true);

                document.addEventListener('mouseleave', (e) => {
                    if (e.target.id === 'inkBlot' && blot) {
                        // Add small delay to prevent flickering
                        setTimeout(() => {
                            if (!blot.element.matches(':hover')) {
                                blot.collapseMenu();
                            }
                        }, 100);
                    }
                }, true);

                // Blot menu item clicks
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('menu-item') && blot) {
                        e.preventDefault();
                        e.stopPropagation();
                        const action = e.target.getAttribute('data-action');
                        blot.executeAction(action);
                        return;
                    }

                    // Blot click handling
                    if (e.target.id === 'inkBlot' && blot) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (!currentThought && thoughts.length > 0) {
                            this.setCurrentThought(thoughts[thoughts.length - 1]);
                        }
                        return;
                    }

                    // Click handling for deselecting thoughts when clicking empty space
                    if (!e.target.classList.contains('thought') && !e.target.closest('.thought')) {
                        if (currentThought) {
                            currentThought.setActive(false);
                            currentThought = null;
                            appMode = 'new_thought';
                            this.updateMouseBlob();
                        }
                    }
                });

                // Unified keyboard input handling - ALL TYPING DETECTED HERE
                document.addEventListener('keydown', (e) => {
                    // If a thought is active, let contentEditable handle most keys
                    if (currentThought && currentThought.isActive) {
                        if (e.key === 'Escape') {
                            e.preventDefault();
                            currentThought.setActive(false);
                            currentThought = null;
                            appMode = 'new_thought';
                            this.updateMouseBlob();
                        }
                        // Let contentEditable handle other keys naturally
                        return;
                    }

                    if (e.key === 'Backspace' || e.key === 'Delete') {
                        e.preventDefault();
                        this.handleDelete();
                    } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
                        // Regular character input
                        e.preventDefault();
                        if (appMode === 'new_thought') {
                            this.createOrUpdateThought(e.key);
                        }
                    }
                });
            }

            updateAppMode() {
                if (currentThought) {
                    // Check if mouse is over blot - if so, don't switch modes
                    const blotRect = document.getElementById('inkBlot').getBoundingClientRect();
                    const mouseOverBlot = mouseX >= blotRect.left && mouseX <= blotRect.right && 
                                         mouseY >= blotRect.top && mouseY <= blotRect.bottom;
                    
                    if (mouseOverBlot) {
                        // Don't change mode when hovering over blot
                        return;
                    }
                    
                    // Calculate distance to thought's bounding box, not just top-left position
                    const rect = currentThought.element.getBoundingClientRect();
                    
                    // Find closest point on the bounding box to the mouse
                    const closestX = Math.max(rect.left, Math.min(mouseX, rect.right));
                    const closestY = Math.max(rect.top, Math.min(mouseY, rect.bottom));
                    
                    const distance = Math.sqrt(
                        (mouseX - closestX) ** 2 + (mouseY - closestY) ** 2
                    );
                    
                    if (distance > CONFIG.typing.mouseStillThreshold) {
                        // Mouse moved far from current thought - switch to new thought mode
                        currentThought.setActive(false);
                        currentThought = null;
                        appMode = 'new_thought';
                    } else {
                        appMode = 'current_thought';
                    }
                } else {
                    appMode = 'new_thought';
                }
                
                this.updateMouseBlob();
            }

            createOrUpdateThought(char) {
                if (char === ' ' || char.length > 1) return;

                const nearbyThought = this.findNearbyThought(mouseX, mouseY);
                
                if (nearbyThought) {
                    nearbyThought.updateText(nearbyThought.text + char);
                    this.setCurrentThought(nearbyThought);
                } else {
                    const newThought = new Thought(char, mouseX, mouseY);
                    document.getElementById('thoughtsContainer').appendChild(newThought.element);
                    thoughts.push(newThought);
                    this.setCurrentThought(newThought);
                }
                
                this.saveThoughts();
            }

            findNearbyThought(x, y) {
                return thoughts.find(thought => {
                    const distance = Math.sqrt((x - thought.x) ** 2 + (y - thought.y) ** 2);
                    return distance < CONFIG.typing.mouseStillThreshold;
                });
            }

            setCurrentThought(thought) {
                if (currentThought) {
                    currentThought.setActive(false);
                }
                currentThought = thought;
                if (thought) {
                    thought.setActive(true);
                    appMode = 'current_thought';
                } else {
                    appMode = 'new_thought';
                }
                this.updateMouseBlob();
                
                // Notify blot of current thought change
                if (blot) {
                    blot.onCurrentThoughtChanged();
                }
            }

            handleDelete() {
                if (appMode === 'current_thought' && currentThought) {
                    // Delete the current thought
                    const index = thoughts.indexOf(currentThought);
                    if (index > -1) {
                        currentThought.element.remove();
                        thoughts.splice(index, 1);
                        currentThought = null;
                        appMode = 'new_thought';
                        this.updateMouseBlob();
                        this.saveThoughts();
                    }
                }
            }

            updateMouseBlob() {
                if (appMode === 'new_thought') {
                    if (!mouseBlob) {
                        mouseBlob = document.createElement('div');
                        mouseBlob.className = 'mouse-blob';
                        document.body.appendChild(mouseBlob);
                    }
                    mouseBlob.style.left = (mouseX - 6) + 'px';
                    mouseBlob.style.top = (mouseY - 6) + 'px';
                } else {
                    if (mouseBlob) {
                        mouseBlob.remove();
                        mouseBlob = null;
                    }
                }
            }

            saveThoughts() {
                const thoughtsData = thoughts.map(t => ({
                    text: t.text,
                    x: t.x,
                    y: t.y,
                    isActive: t.isActive
                }));
                localStorage.setItem(CONFIG.typing.storageKey, JSON.stringify(thoughtsData));
            }

            loadThoughts() {
                const saved = localStorage.getItem(CONFIG.typing.storageKey);
                if (saved) {
                    const thoughtsData = JSON.parse(saved);
                    thoughtsData.forEach(data => {
                        const thought = new Thought(data.text, data.x, data.y);
                        document.getElementById('thoughtsContainer').appendChild(thought.element);
                        thoughts.push(thought);
                        
                        if (data.isActive) {
                            this.setCurrentThought(thought);
                        }
                    });
                }
            }
        }

        // === CLEAR FUNCTIONALITY ===
        function clearAllThoughts() {
            // Remove all thought elements
            thoughts.forEach(thought => thought.remove());
            
            // Clear arrays and state
            thoughts = [];
            currentThought = null;
            appMode = 'new_thought';
            
            // Update UI
            if (thoughtManager) {
                thoughtManager.updateMouseBlob();
            }
            
            // Clear storage
            localStorage.removeItem(CONFIG.typing.storageKey);
            
            // Notify blot of current thought change
            if (blot) {
                blot.onCurrentThoughtChanged();
                if (blot.menuExpanded) {
                    blot.collapseMenu();
                }
            }
        }

        // === INITIALIZATION ===
        let thoughtManager;

        document.addEventListener('DOMContentLoaded', () => {
            thoughtManager = new ThoughtManager();
            blot = new Blot();
            
            // Setup clear button
            document.getElementById('clearButton').addEventListener('click', clearAllThoughts);
        });
    </script>
</body>
</html>